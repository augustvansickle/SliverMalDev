#!/usr/bin/env python3
"""
Shellcode XOR Encryptor
Encrypts raw shellcode and outputs C-style array

Usage:
    python3 encrypt_shellcode.py payload.bin
    python3 encrypt_shellcode.py payload.bin --key "CUSTOMKEY"
"""

import sys
import argparse
from pathlib import Path

def xor_encrypt(data: bytes, key: bytes) -> bytes:
    """XOR encrypt data with key"""
    return bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])

def format_c_array(data: bytes, var_name: str = "encrypted_shellcode", bytes_per_line: int = 12) -> str:
    """Format bytes as C array"""
    lines = []
    lines.append(f"unsigned char {var_name}[] = {{")
    
    for i in range(0, len(data), bytes_per_line):
        chunk = data[i:i + bytes_per_line]
        hex_bytes = ", ".join(f"0x{b:02x}" for b in chunk)
        if i + bytes_per_line < len(data):
            lines.append(f"    {hex_bytes},")
        else:
            lines.append(f"    {hex_bytes}")
    
    lines.append("};")
    lines.append(f"\nSIZE_T shellcode_size = {len(data)};")
    
    return "\n".join(lines)

def format_key_array(key: bytes) -> str:
    """Format key as C array"""
    hex_bytes = ", ".join(f"0x{b:02x}" for b in key)
    comment = "".join(chr(b) if 32 <= b < 127 else '.' for b in key)
    return f'unsigned char xor_key[] = {{ {hex_bytes} }}; // "{comment}"'

def main():
    parser = argparse.ArgumentParser(description="XOR encrypt shellcode for C loader")
    parser.add_argument("shellcode", help="Path to raw shellcode file (e.g., payload.bin)")
    parser.add_argument("--key", "-k", default="MALDEV", help="XOR key (default: MALDEV)")
    parser.add_argument("--output", "-o", help="Output file (default: stdout)")
    parser.add_argument("--raw", "-r", action="store_true", help="Output raw encrypted bytes")
    args = parser.parse_args()
    
    # Read shellcode
    shellcode_path = Path(args.shellcode)
    if not shellcode_path.exists():
        print(f"[!] File not found: {shellcode_path}", file=sys.stderr)
        sys.exit(1)
    
    shellcode = shellcode_path.read_bytes()
    print(f"[*] Read {len(shellcode)} bytes from {shellcode_path}", file=sys.stderr)
    
    # Encrypt
    key = args.key.encode()
    encrypted = xor_encrypt(shellcode, key)
    print(f"[*] Encrypted with key: {args.key}", file=sys.stderr)
    
    # Output
    if args.raw:
        output = encrypted
    else:
        output = f"""// Generated by encrypt_shellcode.py
// Original size: {len(shellcode)} bytes
// Key: {args.key}

{format_key_array(key)}

{format_c_array(encrypted)}

// Paste the above into loader.c, replacing the placeholder shellcode
"""
    
    if args.output:
        if args.raw:
            Path(args.output).write_bytes(output)
        else:
            Path(args.output).write_text(output)
        print(f"[+] Written to {args.output}", file=sys.stderr)
    else:
        if args.raw:
            sys.stdout.buffer.write(output)
        else:
            print(output)
    
    # Verify decryption works
    decrypted = xor_encrypt(encrypted, key)
    if decrypted == shellcode:
        print("[+] Verification: decryption successful", file=sys.stderr)
    else:
        print("[!] Verification FAILED!", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
